<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Assembly | James D'Souza</title><meta name=keywords content><meta name=description content="What&rsquo;s the goal? In early January, a friend messaged saying that he was doing Day 1 of Advent of Code in Assembly Code, and it was a really interesting challenge. As someone who has never touched Assembly Code, I naively thought how hard can it be?, and decided to join him.
 I&rsquo;m running this on an ARM Macbook, so this post relates to my experiences with that architecture. Working with an Intel instruction set will vary, but the most of the ideas should be relatively transferrable as I&rsquo;m not using any complex instructions here."><meta name=author content><link rel=canonical href=https://j-dsouza.github.io/posts/2022-01-advent-of-code-assembly/><link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.4dcb3c4f38462f66c6b6137227726f5543cb934cca9788f041c087e374491df2.js integrity="sha256-Tcs8TzhGL2bGthNyJ3JvVUPLk0zKl4jwQcCH43RJHfI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://j-dsouza.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://j-dsouza.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://j-dsouza.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://j-dsouza.github.io/apple-touch-icon.png><link rel=mask-icon href=https://j-dsouza.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.96.0"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Assembly"><meta property="og:description" content="What&rsquo;s the goal? In early January, a friend messaged saying that he was doing Day 1 of Advent of Code in Assembly Code, and it was a really interesting challenge. As someone who has never touched Assembly Code, I naively thought how hard can it be?, and decided to join him.
 I&rsquo;m running this on an ARM Macbook, so this post relates to my experiences with that architecture. Working with an Intel instruction set will vary, but the most of the ideas should be relatively transferrable as I&rsquo;m not using any complex instructions here."><meta property="og:type" content="article"><meta property="og:url" content="https://j-dsouza.github.io/posts/2022-01-advent-of-code-assembly/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-01-08T10:15:19+00:00"><meta property="article:modified_time" content="2022-01-08T10:15:19+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Assembly"><meta name=twitter:description content="What&rsquo;s the goal? In early January, a friend messaged saying that he was doing Day 1 of Advent of Code in Assembly Code, and it was a really interesting challenge. As someone who has never touched Assembly Code, I naively thought how hard can it be?, and decided to join him.
 I&rsquo;m running this on an ARM Macbook, so this post relates to my experiences with that architecture. Working with an Intel instruction set will vary, but the most of the ideas should be relatively transferrable as I&rsquo;m not using any complex instructions here."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://j-dsouza.github.io/posts/"},{"@type":"ListItem","position":3,"name":"Assembly","item":"https://j-dsouza.github.io/posts/2022-01-advent-of-code-assembly/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Assembly","name":"Assembly","description":"What\u0026rsquo;s the goal? In early January, a friend messaged saying that he was doing Day 1 of Advent of Code in Assembly Code, and it was a really interesting challenge. As someone who has never touched Assembly Code, I naively thought how hard can it be?, and decided to join him.\n I\u0026rsquo;m running this on an ARM Macbook, so this post relates to my experiences with that architecture. Working with an Intel instruction set will vary, but the most of the ideas should be relatively transferrable as I\u0026rsquo;m not using any complex instructions here.","keywords":[],"articleBody":"What’s the goal? In early January, a friend messaged saying that he was doing Day 1 of Advent of Code in Assembly Code, and it was a really interesting challenge. As someone who has never touched Assembly Code, I naively thought how hard can it be?, and decided to join him.\n I’m running this on an ARM Macbook, so this post relates to my experiences with that architecture. Working with an Intel instruction set will vary, but the most of the ideas should be relatively transferrable as I’m not using any complex instructions here.\n The challenge boiled down to reading a list of numbers, and counting how many of them are larger than the previous number in the list. For example, in the following example there are 7 numbers that are larger than the previous number:\n199 (N/A - no previous measurement) 200 (increased) 208 (increased) 210 (increased) 200 (decreased) 207 (increased) 240 (increased) 269 (increased) 260 (decreased) 263 (increased) Easy, right? This is a pretty basic problem to solve in most modern programming languages, but without some of the abstractions provided to you by a modern programming language, things are not quite so easy..\nThe code I ended up writing to solve this and print the answer to stdout can be found on my github\nHow do you even run an assembly program? To run an assembly program, like with any other programming language, you need to turn the code that you have written into something that the machine can understand. Whilst assembly is close to direct machine code, its not quite there. In order to run it, we need to pass it through two programs, an assembler, and a linker. Both of these conveniently come with Mac developer tools, and the program names are as and ld respectively.\nAn assembler’s job is to convert assembly language mnemonics (instructions) into binary machine language, and translate names for memory addresses into numeric addresses.\nThe end result of the assembler is a binary ‘object’ file, given a .o extension by convention. The memory addresses generated by an assembler are actually offsets, as opposed to absolute locations. Generally, an object file will be linked with several other object files and libraries to produce a program.\nThe job of a linker is to link together these object files and libraries, by assigning absolute memory locations to everything. The output of this is a binary executable which can be directly run from the command line. In this post, we are only dealing with one assembly file, so there are no other object files or libraries to worry about, however, it does need to link our memory addresses to something that the operating system can understand.\nUsage of these two is reasonably simple. I made a small makefile to save on typing, but you would run something like the following in order to generate a binary executable called bin/filename from a source assembly file called filename.s\nas -o filename.o filename.s ld filename -o ./bin/filename -e _start -arch arm64 -L /Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/lib -lSystem Our first assembly program Lets look at an extremely simple assembly program. The following codeblock is a Hello World program that will print out the string Hello World! when run.\nHello world in assembly .global _start @ Provide program starting address to linker helloworld:.ascii \"Hello World!\\n\"  @ Setup the parameters to print hello world @ and then call Linux to do it.  _start: mov X0, #1 @ 1 = StdOut  adr X1, helloworld @ string to print  mov X2, #13 @ length of our string  mov X16, #4 @ MacOS write system call  svc 0 @ Call linux to output the string  @ Setup the parameters to exit the program @ and then call Linux to do it.   mov X0, #0 @ Use 0 return code  mov X16, #1 @ Service command code 1 terminates this program  svc 0 @ Call MacOS to terminate the program  \nThere are a few interesting things to note. Starting from the top..\n.global _start @ Provide program starting address to linker helloworld:.ascii \"Hello World!\\n\" In the above code, the .global directive allows you to mark specific parts of your code to ensure that they are added to the object code (.o file), in order for the linker to find them. In the commands above, this is what allows the linker to use the -e _start flag to understand where to begin the code. In conjunction with the flag in the linker, we are telling the program where it should start.\nThe second line is pretty self-explanatory, and allows us to easily define the string \"Hello World\" in ascii. Importantly, we can refer to this from other places in our code so it acts like an immutable variable.\n_start: mov X0, #1 @ 1 = StdOut This is our first real line of code. The very first part, _start, tells the linker that this is the beginning of our program, as mentiond above. We then have our first instruction, mov. Instructions are the building blocks of any assembly language program, and they generally take the form of an instruction followed by two or three parameters. The mov instruction simply moves the thing from the second parameter into the first parameter. In this case, we are moving the number 1 into register X0.\nRegisters are areas which contain very fast storage inside the processor. They can either hold values, or point to specific memory locations. In my M1 Pro chip, there are 29 general-purpose registers (x0-x28), plus a number of special registers. The only special register that we will be dealing with is sp, or the stack pointer. This is used to point to an area of memory that you are using in your program.\n_start: mov X0, #1 @ 1 = StdOut  adr X1, helloworld @ string to print  mov X2, #13 @ length of our string  mov X16, #4 @ MacOS write system call  svc 0 @ Call linux to output the string The above block of code constitutes a syscall. This is the process of our program interacting with the outside world, ie, the operating system itself. The secret incantation required to perform different types of syscall varies depending on your processor, but essentially requires putting data into the correct registers, then calling the instruction scv 0.\nThe syscall above is to write to stdout. What we had to do here was to put the correct Mac syscall code into the x16 register, and then you pass the arguments to the syscall into x0 through x2. We can look up the required arguments and the order we need to pass them in by looking at the man page for the write function, using man 2 write, or similar for whichever syscall we are attempting to do.\nReading a file There are several ways we could have read in our data, for example simply defining it inside our program, or passing it in through stdout. For this challenge, I decided to read the input from a file. To do this, we need to interact with the operating system, ie, use a syscall. There are three steps required as part of reading a file, all of which require different syscalls:\n Open the file in read mode Read the contents of the file Close the file  As mentioned above, we can use Apple’s documentation, coupled with the man pages to get documentation of how to use these syscalls, and ultimately we end up with the following code in order to open the file and read our data into memory.\nReading from file in assembly .text filename:.ascii \"/path/to/file\"  _start: @ Open the file to read input  adr x0, filename @ Filename  mov x1, #0 @ Read only  mov x16, #5 @ Open  svc 0 @ Call   mov x19, x0 @ Save file descriptor  @ (non-negative integer == success) to x19  @ Read from file  sub sp, sp, 0x10000 @ Allocate 2^16 bits on the stack  mov x1, sp @ Buffer address (on the stack)  mov x2, 0x10000 @ Buffer size  mov x16, #3 @ Read  svc 0 @ Call   mov x20, x0 @ Returns the amount of bytes read. Store in x20  @ Close file  mov x0, x19 @ Move file descriptor back to x0  mov x16, #6 @ Close  svc 0 @ Call  \nAt this point, we have our file contents in memory at the location referred to by sp. All of the data has been read in as ASCII characters, which means we could successfully print those characters out to stdout, but that is not ideal for doing numeric calculations.\nConverting ASCII characters to numbers In memory right now, we will have something like the ASCII row shown below. Below it is the integer representation of each of the ASCII characters. Ultimately, we want to get to a point where we have numbers, for example 199 and 200, stored in a way where we can access each number in turn.\nASCII | 49 57 57 10 50 48 48 10 int | 1 9 9 \\n 2 0 0 \\n To perform the conversion, we need to run through memory starting at sp, and then:\n Check for a newline - If there is one, we are at the end of the number Convert to an integer Multiply previous total by 10 Add new number to previous total Repeat until you hit a newline  So, if we are reading 199\\n (from the example above), we will do:\nPrevious total | New digit 0 | 49 - 1 1 (x10 = 10) | 57 - 9 19 (x10 = 190) | 59 - 9 199 | \\n - Done Once we have our number, we can overwrite the digit in the stack. As our numbers will fit into a 32 bit int (=4 bytes, or ASCII chars), we can freely overwrite past data without accidentally altering data we haven’t read yet.\nThe code to do this is as follows:\nConvert ASCII characters into numbers  mov x9, sp @ 1. Read position in the buffer  mov x10, sp @ 2. Write position in the buffer  mov x11, 0 @ 3. Accumulated total  mov x12, 0 @ 4. Current byte we're reading  mov x13, sp @ 5. The end of our useful information. sp =  add x13, x13, x20 @ start of our information. x20 contains  add x13, x13, x20 @ the amount of bytes that we read from  add x13, x13, 1 @ the file.  _convert_loop_start:  ldrb w12, [x9] @ Read value at x9 into x12 (1 byte)  cmp x12, 10 @ If x12 == 10 (= \\n)  beq _convert_loop_newline @ Then branch to newline code  sub x12, x12, 48 @ Else sub 48 to get back to real number  mov x14, 10 @ So we can multiply by 10  mul x11, x11, x14 @ Multiply accumulated total by 10  add x11, x11, x12 @ Add new digit to accumulated total   b _convert_loop_end @ Glorious success  _convert_loop_newline:  str w11, [x10] @ Store x11 (accumulated total) at memory  @ position of x10 (write position)  add x10, x10, 4 @ Increment x10 (write position) by 4 bytes  mov x11, 0 @ Reset x11 (accumulated total)   @ Onwards to _convert_loop_end  _convert_loop_end:  add x9, x9, 1 @ Increment x9 (read position) by 1 byte  cmp x13, x9 @ Compare read position against end of buffer  bne _convert_loop_start @ If not at end of buffer   str w11, [x10] @ Store our last number  \n Note: At this point, we have stored the memory location of the start of our data inside the stack pointer, sp and the end of our data is in x13. These will both be useful in future\n There are a few new things in this code, namely the comparison , cmp, and branching, beq, bne operators. These are the fundamental building blocks of if statements and loops in modern programming languages. As you can see, we are also starting to write something resembling functions, eg _convert_loop_start, which are used to add some sense and readability to our control flow.\nComparison and branching operators allow us to write code such as the following very basic if statement - This can quite easily be turned into loops by jumping to an instruction further above the point in the program you are in at any point:\ncmp x12, 10 @ Compare the value in register x12 to 10 bne _code_to_run_if_not_equal @ If x12 != 10, jump to the section of code called _code_to_run_if_not_equal add x12, 10 @ Otherwise, add 10 to the value in register x12 After reading the advent of code input file into memory, we can read the contents using lldb to check that it contains what we expected. Lldb gives the following output when we read the first 16 blocks of memory at our stack pointer:\n(lldb) x/16x `$sp` 0x16fdef5c0: 0x000000bf 0x000000b9 0x000000bc 0x000000bd 0x16fdef5d0: 0x000000cc 0x000000d5 0x000000d7 0x000000e3 0x16fdef5e0: 0x000000de 0x000000dd 0x000000ec 0x000000eb 0x16fdef5f0: 0x000000ec 0x000000e8 0x000000e0 0x000000e4  Note: These numbers are “little-endian”, ie, numbers towards the right are less significant than those on the left\n Using a Hex converter, we can translate this to the numbers that this represents, which luckily represents the correct numbers:\n0x16fdef5c0: 191 185 188 189 0x16fdef5d0: 204 213 215 227 0x16fdef5e0: 222 221 236 235 0x16fdef5f0: 236 232 224 228 Performing the calculation Now, we have our numbers stored in memory correctly, we need to perform our calculation. This invovles looping through the numbers, comparing each number to the previous one. If the next number is larger than the previous, we need to increment a counter by 1.\nPerform increment calculation _processing_start:  add x9, sp, 4 @ 1. Read position in the buffer (start off  @ at sp + 2. This lets us avoid any issues  @ relating to the first number having  @ nothing to compare against)  ldr w11, [sp] @ 2. Previous 32-bit number  mov x12, 0 @ 3. Current 32-bit number  mov x14, 0 @ 4. A counter tracking increases  add x13, x10, 4 @ 5. The end of our useful information  _count_loop_start:  ldr w12, [x9] @ Load current number into x12 (use w12 to  @ get 32 bits)  cmp x12, x11 @ Compare w12 and w11  blt _count_loop_no_increment @ If less than, don't increment counter  _count_loop_increment:  add x14, x14, 1 @ Increment x14 (counter) by 1  _count_loop_no_increment:  mov x11, x12 @ Move current number into previous number  add x9, x9, 4 @ Add 2 to read position  cmp x9, x13 @ Compare current read position to end of  @ useful info  bne _count_loop_start @ If not yet at end of file, back to start of  @ loop  \nIn the above code, we are using the register x14 as our counter, and therefore out answer should be inside that register. Unfortunately, it is a 32-bit integer, so we need to convert it back to ASCII so that we can display it.\nPrinting our our answer We can use a similar trick to before to do this conversion - Namely, we need to repeatedly divide the number by 10 and store the remainder, converting all of our remainders into ASCII until we get to the end of the number.\nFor example:\n1709 / 10 = 170 | 9 170 / 10 = 17 | 0 17 / 10 = 1 | 7 1 / 10 = 0 | 1 Reading backwards, we get our number in single integers. We can then add 48 to each of these to get our ASCII characters, and finally print to stdout.\nConvert integer to ASCII and print to stdout _print_start:  mov x9, 0 @ The remainder  mov x10, x14 @ Our remaining number  mov x11, 0 @ A counter of number of digits  mov x12, 10 @ To help divide by 10  mov x13, sp @ Write location for the characters to print  add x13, x13, 3 @ Cheating a bit - I know the output is 4  @ digits, so this lets us start at a position  @ on the stack and work backwards without  @ running out of room.  mov x15, 0 @ Helper  mov x17, 0 @ Another helper  _print_loop_start:  udiv x15, x10, x12 @ Stores quotient in x15  mov x17, x10 @ Store original number in x17  mov x10, x15 @ Store quotient in x10  mul x15, x15, x12 @ Store quotient * 10 in x15  sub x9, x17, x15 @ Calculate remainder   add x9, x9, 48 @ Convert to ascii  strb w9, [x13] @ Store character in memory   add x11, x11, 1 @ Add 1 to counter  sub x13, x13, 1 @ Decrease write location by 1   cmp x10, 0 @ If quotient = 0, we are done  bne _print_loop_start @ Else, back to our print loop   add x11, x11, 1 @ Add 1 to counter to print the final digit  _print_to_stdout:  mov x0, #1 @ 1 = stdout  mov x1, x13 @ String to print out  mov x2, x11 @ length of string  mov x16, #4 @ write  svc 0 @ Call  _exit:  mov x0, #0 @ Use 0 return code  mov x16, #1 @ Exit program  svc 0 @ Call  \nAnd finally, our answer has been printed to the console!\nWhat did I learn? It’s really interesting trying to write code with literally zero abstractions - You have to really think about how computers work in their most basic form. I’d recommend it as a challenge to anyone who likes computers.\nI’d never properly thought about how a program interacts with the operating system through syscalls, though it makes a lot of sense having been through this process.\nThough my implementation is almost certainly not the most efficient from either a performance or lines-of-code perspective, the fact that this took over 200 lines of assembly code (admittedly a fair few of them are comments!) has really given me an appreciation of what early programmers accomplished, as well as a huge appreciation for how easy higher-level languages have made programming. You could write this program quite comfortably in 3 lines of Python!!\nReferences A few interesting links that I found during this that really helped me during this process.\nReading from a file\nLLDB cheatsheet\nHex converter\nSome basics\n","wordCount":"3026","inLanguage":"en","datePublished":"2022-01-08T10:15:19Z","dateModified":"2022-01-08T10:15:19Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://j-dsouza.github.io/posts/2022-01-advent-of-code-assembly/"},"publisher":{"@type":"Organization","name":"James D'Souza","logo":{"@type":"ImageObject","url":"https://j-dsouza.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://j-dsouza.github.io accesskey=h title="James D'Souza (Alt + H)">James D'Souza</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Assembly</h1><div class=post-meta><span title="2022-01-08 10:15:19 +0000 UTC">January 8, 2022</span></div></header><div class=post-content><h1 id=whats-the-goal>What&rsquo;s the goal?<a hidden class=anchor aria-hidden=true href=#whats-the-goal>#</a></h1><p>In early January, a friend messaged saying that he was doing Day 1 of <a href=https://adventofcode.com/>Advent of Code</a> in Assembly Code, and it was a really interesting challenge. As someone who has never touched Assembly Code, I naively thought <em>how hard can it be?</em>, and decided to join him.</p><blockquote><p>I&rsquo;m running this on an ARM Macbook, so this post relates to my experiences with that architecture. Working with an Intel instruction set will vary, but the most of the ideas should be relatively transferrable as I&rsquo;m not using any complex instructions here.</p></blockquote><p>The <a href=https://adventofcode.com/2021/day/1>challenge</a> boiled down to reading a list of numbers, and counting how many of them are larger than the previous number in the list. For example, in the following example there are <code>7</code> numbers that are larger than the previous number:</p><pre tabindex=0><code>199 (N/A - no previous measurement)
200 (increased)
208 (increased)
210 (increased)
200 (decreased)
207 (increased)
240 (increased)
269 (increased)
260 (decreased)
263 (increased)
</code></pre><p>Easy, right? This is a pretty basic problem to solve in most modern programming languages, but without some of the abstractions provided to you by a modern programming language, things are not quite so easy..</p><p>The code I ended up writing to solve this and print the answer to stdout can be found <a href=https://github.com/j-dsouza/assembly>on my github</a></p><h1 id=how-do-you-even-run-an-assembly-program>How do you even run an assembly program?<a hidden class=anchor aria-hidden=true href=#how-do-you-even-run-an-assembly-program>#</a></h1><p>To run an assembly program, like with any other programming language, you need to turn the code that you have written into something that the machine can understand. Whilst assembly is <em>close</em> to direct machine code, its not quite there. In order to run it, we need to pass it through two programs, an assembler, and a linker. Both of these conveniently come with Mac developer tools, and the program names are <code>as</code> and <code>ld</code> respectively.</p><p>An <strong>assembler</strong>&rsquo;s job is to convert assembly language mnemonics (instructions) into binary machine language, and translate names for memory addresses into numeric addresses.</p><p>The end result of the assembler is a binary &lsquo;object&rsquo; file, given a <code>.o</code> extension by convention. The memory addresses generated by an assembler are actually offsets, as opposed to absolute locations. Generally, an object file will be linked with several other object files and libraries to produce a program.</p><p>The job of a <strong>linker</strong> is to link together these object files and libraries, by assigning absolute memory locations to everything. The output of this is a binary executable which can be directly run from the command line. In this post, we are only dealing with one assembly file, so there are no other object files or libraries to worry about, however, it does need to link our memory addresses to something that the operating system can understand.</p><p>Usage of these two is reasonably simple. I made a <a href=https://github.com/j-dsouza/assembly/blob/main/Makefile>small makefile</a> to save on typing, but you would run something like the following in order to generate a binary executable called <code>bin/filename</code> from a source assembly file called <code>filename.s</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>as -o filename.o filename.s
</span></span><span style=display:flex><span>ld filename -o ./bin/filename -e _start -arch arm64 -L /Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/lib -lSystem
</span></span></code></pre></div><h1 id=our-first-assembly-program>Our first assembly program<a hidden class=anchor aria-hidden=true href=#our-first-assembly-program>#</a></h1><p>Lets look at an extremely simple assembly program. The following codeblock is a Hello World program that will print out the string <code>Hello World!</code> when run.</p><p><details><summary markdown=span>Hello world in assembly</summary><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-armasm data-lang=armasm><span style=display:flex><span><span style=color:#f92672>.global</span> _start              <span style=color:#75715e>@ Provide program starting address to linker
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>helloworld:<span style=color:#f92672>      .ascii  </span>&#34;<span style=color:#e6db74>Hello World!\n</span>&#34;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>@ Setup the parameters to print hello world
</span></span></span><span style=display:flex><span><span style=color:#75715e>@ and then call Linux to do it.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>_start: mov <span style=color:#960050;background-color:#1e0010>X0</span>, #<span style=color:#ae81ff>1</span>          <span style=color:#75715e>@ 1 = StdOut
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        adr <span style=color:#960050;background-color:#1e0010>X1</span>, <span style=color:#960050;background-color:#1e0010>helloworld</span>  <span style=color:#75715e>@ string to print
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        mov <span style=color:#960050;background-color:#1e0010>X2</span>, #<span style=color:#ae81ff>13</span>         <span style=color:#75715e>@ length of our string
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        mov <span style=color:#960050;background-color:#1e0010>X16</span>, #<span style=color:#ae81ff>4</span>         <span style=color:#75715e>@ MacOS write system call
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        svc 0               <span style=color:#75715e>@ Call linux to output the string
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>@ Setup the parameters to exit the program
</span></span></span><span style=display:flex><span><span style=color:#75715e>@ and then call Linux to do it.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        mov     <span style=color:#960050;background-color:#1e0010>X0</span>, #<span style=color:#ae81ff>0</span>      <span style=color:#75715e>@ Use 0 return code
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        mov     <span style=color:#960050;background-color:#1e0010>X16</span>, #<span style=color:#ae81ff>1</span>     <span style=color:#75715e>@ Service command code 1 terminates this program
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        svc     0           <span style=color:#75715e>@ Call MacOS to terminate the program
</span></span></span></code></pre></div></details></p><p>There are a few interesting things to note. Starting from the top..</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-armasm data-lang=armasm><span style=display:flex><span><span style=color:#f92672>.global</span> _start              <span style=color:#75715e>@ Provide program starting address to linker
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>helloworld:<span style=color:#f92672>      .ascii </span>&#34;<span style=color:#e6db74>Hello World!\n</span>&#34;
</span></span></code></pre></div><p>In the above code, the <code>.global</code> directive allows you to mark specific parts of your code to ensure that they are added to the object code (<code>.o</code> file), in order for the linker to find them. In the commands above, this is what allows the linker to use the <code>-e _start</code> flag to understand where to begin the code. In conjunction with the flag in the linker, we are telling the program where it should start.</p><p>The second line is pretty self-explanatory, and allows us to easily define the string <code>"Hello World"</code> in ascii. Importantly, we can refer to this from other places in our code so it acts like an immutable variable.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-armasm data-lang=armasm><span style=display:flex><span>_start: mov <span style=color:#960050;background-color:#1e0010>X0</span>, #<span style=color:#ae81ff>1</span>          <span style=color:#75715e>@ 1 = StdOut
</span></span></span></code></pre></div><p>This is our first <em>real</em> line of code. The very first part, <code>_start</code>, tells the linker that this is the beginning of our program, as mentiond above. We then have our first instruction, <code>mov</code>. Instructions are the building blocks of any assembly language program, and they generally take the form of an instruction followed by two or three parameters. The <code>mov</code> instruction simply moves the thing from the second parameter into the first parameter. In this case, we are moving the number <code>1</code> into register <code>X0</code>.</p><p>Registers are areas which contain very fast storage inside the processor. They can either hold values, or point to specific memory locations. In my M1 Pro chip, there are 29 general-purpose registers (<code>x0</code>-<code>x28</code>), plus a number of special registers. The only special register that we will be dealing with is <code>sp</code>, or the stack pointer. This is used to point to an area of memory that you are using in your program.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-armasm data-lang=armasm><span style=display:flex><span>_start: mov <span style=color:#960050;background-color:#1e0010>X0</span>, #<span style=color:#ae81ff>1</span>          <span style=color:#75715e>@ 1 = StdOut
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        adr <span style=color:#960050;background-color:#1e0010>X1</span>, <span style=color:#960050;background-color:#1e0010>helloworld</span>  <span style=color:#75715e>@ string to print
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        mov <span style=color:#960050;background-color:#1e0010>X2</span>, #<span style=color:#ae81ff>13</span>         <span style=color:#75715e>@ length of our string
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        mov <span style=color:#960050;background-color:#1e0010>X16</span>, #<span style=color:#ae81ff>4</span>         <span style=color:#75715e>@ MacOS write system call
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        svc 0               <span style=color:#75715e>@ Call linux to output the string
</span></span></span></code></pre></div><p>The above block of code constitutes a syscall. This is the process of our program interacting with the outside world, ie, the operating system itself. The secret incantation required to perform different types of syscall varies depending on your processor, but essentially requires putting data into the correct registers, then calling the instruction <code>scv 0</code>.</p><p>The syscall above is to write to stdout. What we had to do here was to put the correct <a href=https://opensource.apple.com/source/xnu/xnu-1504.3.12/bsd/kern/syscalls.master>Mac syscall code</a> into the <code>x16</code> register, and then you pass the arguments to the syscall into <code>x0</code> through <code>x2</code>. We can look up the required arguments and the order we need to pass them in by looking at the man page for the <code>write</code> function, using <code>man 2 write</code>, or similar for whichever syscall we are attempting to do.</p><h1 id=reading-a-file>Reading a file<a hidden class=anchor aria-hidden=true href=#reading-a-file>#</a></h1><p>There are several ways we could have read in our data, for example simply defining it inside our program, or passing it in through <code>stdout</code>. For this challenge, I decided to read the input from a file. To do this, we need to interact with the operating system, ie, use a syscall. There are three steps required as part of reading a file, all of which require different syscalls:</p><ol><li>Open the file in read mode</li><li>Read the contents of the file</li><li>Close the file</li></ol><p>As mentioned above, we can use Apple&rsquo;s documentation, coupled with the man pages to get documentation of how to use these syscalls, and ultimately we end up with the following code in order to open the file and read our data into memory.</p><p><details><summary markdown=span>Reading from file in assembly</summary><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-armasm data-lang=armasm><span style=display:flex><span><span style=color:#f92672>.text</span>
</span></span><span style=display:flex><span>filename:<span style=color:#f92672>     .ascii </span>&#34;<span style=color:#e6db74>/path/to/file</span>&#34;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>_start:
</span></span><span style=display:flex><span><span style=color:#75715e>@ Open the file to read input
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    adr <span style=color:#a6e22e>x0</span>, <span style=color:#960050;background-color:#1e0010>filename</span>     <span style=color:#75715e>@ Filename
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    mov <span style=color:#a6e22e>x1</span>, #<span style=color:#ae81ff>0</span>           <span style=color:#75715e>@ Read only
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    mov <span style=color:#a6e22e>x16</span>, #<span style=color:#ae81ff>5</span>          <span style=color:#75715e>@ Open
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    svc 0                <span style=color:#75715e>@ Call
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    mov <span style=color:#a6e22e>x19</span>, <span style=color:#a6e22e>x0</span>          <span style=color:#75715e>@ Save file descriptor
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                         <span style=color:#75715e>@ (non-negative integer == success) to x19
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>@ Read from file
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    sub <span style=color:#960050;background-color:#1e0010>sp</span>, <span style=color:#960050;background-color:#1e0010>sp</span>, <span style=color:#960050;background-color:#1e0010>0</span><span style=color:#a6e22e>x10</span><span style=color:#960050;background-color:#1e0010>000</span>  <span style=color:#75715e>@ Allocate 2^16 bits on the stack
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    mov <span style=color:#a6e22e>x1</span>, <span style=color:#960050;background-color:#1e0010>sp</span>           <span style=color:#75715e>@ Buffer address (on the stack)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    mov <span style=color:#a6e22e>x2</span>, <span style=color:#960050;background-color:#1e0010>0</span><span style=color:#a6e22e>x10</span><span style=color:#960050;background-color:#1e0010>000</span>      <span style=color:#75715e>@ Buffer size
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    mov <span style=color:#a6e22e>x16</span>, #<span style=color:#ae81ff>3</span>          <span style=color:#75715e>@ Read
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    svc 0                <span style=color:#75715e>@ Call
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    mov <span style=color:#a6e22e>x20</span>, <span style=color:#a6e22e>x0</span>          <span style=color:#75715e>@ Returns the amount of bytes read. Store in x20
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>@ Close file
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    mov <span style=color:#a6e22e>x0</span>, <span style=color:#a6e22e>x19</span>          <span style=color:#75715e>@ Move file descriptor back to x0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    mov <span style=color:#a6e22e>x16</span>, #<span style=color:#ae81ff>6</span>          <span style=color:#75715e>@ Close
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    svc 0                <span style=color:#75715e>@ Call
</span></span></span></code></pre></div></details></p><p>At this point, we have our file contents in memory at the location referred to by <code>sp</code>. All of the data has been read in as ASCII characters, which means we could successfully print those characters out to <code>stdout</code>, but that is not ideal for doing numeric calculations.</p><h1 id=converting-ascii-characters-to-numbers>Converting ASCII characters to numbers<a hidden class=anchor aria-hidden=true href=#converting-ascii-characters-to-numbers>#</a></h1><p>In memory right now, we will have something like the <code>ASCII</code> row shown below. Below it is the integer representation of each of the ASCII characters. Ultimately, we want to get to a point where we have numbers, for example <code>199</code> and <code>200</code>, stored in a way where we can access each number in turn.</p><pre tabindex=0><code>ASCII | 49 57 57 10 50 48 48 10
int   | 1  9  9  \n 2  0  0  \n
</code></pre><p>To perform the conversion, we need to run through memory starting at sp, and then:</p><ol><li>Check for a newline - If there is one, we are at the end of the number</li><li>Convert to an integer</li><li>Multiply previous total by 10</li><li>Add new number to previous total
Repeat until you hit a newline</li></ol><p>So, if we are reading 199\n (from the example above), we will do:</p><pre tabindex=0><code>Previous total | New digit
0              | 49 -&gt; 1
1 (x10 = 10)   | 57 -&gt; 9
19 (x10 = 190) | 59 -&gt; 9
199            | \n -&gt; Done
</code></pre><p>Once we have our number, we can overwrite the digit in the stack. As our numbers will fit into a 32 bit int (=4 bytes, or ASCII chars), we can freely overwrite past data without accidentally altering data we haven&rsquo;t read yet.</p><p>The code to do this is as follows:</p><p><details><summary markdown=span>Convert ASCII characters into numbers</summary><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-armasm data-lang=armasm><span style=display:flex><span>    mov <span style=color:#a6e22e>x9</span>, <span style=color:#960050;background-color:#1e0010>sp</span>                  <span style=color:#75715e>@ 1. Read position in the buffer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    mov <span style=color:#a6e22e>x10</span>, <span style=color:#960050;background-color:#1e0010>sp</span>                 <span style=color:#75715e>@ 2. Write position in the buffer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    mov <span style=color:#a6e22e>x11</span>, <span style=color:#960050;background-color:#1e0010>0</span>                  <span style=color:#75715e>@ 3. Accumulated total
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    mov <span style=color:#a6e22e>x12</span>, <span style=color:#960050;background-color:#1e0010>0</span>                  <span style=color:#75715e>@ 4. Current byte we&#39;re reading
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    mov <span style=color:#a6e22e>x13</span>, <span style=color:#960050;background-color:#1e0010>sp</span>                 <span style=color:#75715e>@ 5. The end of our useful information. sp =
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    add <span style=color:#a6e22e>x13</span>, <span style=color:#a6e22e>x13</span>, <span style=color:#a6e22e>x20</span>           <span style=color:#75715e>@    start of our information. x20 contains
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    add <span style=color:#a6e22e>x13</span>, <span style=color:#a6e22e>x13</span>, <span style=color:#a6e22e>x20</span>           <span style=color:#75715e>@    the amount of bytes that we read from
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    add <span style=color:#a6e22e>x13</span>, <span style=color:#a6e22e>x13</span>, <span style=color:#960050;background-color:#1e0010>1</span>             <span style=color:#75715e>@    the file.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>_convert_loop_start:
</span></span><span style=display:flex><span>    ldrb <span style=color:#a6e22e>w12</span>, <span style=color:#960050;background-color:#1e0010>[</span><span style=color:#a6e22e>x9</span><span style=color:#960050;background-color:#1e0010>]</span>              <span style=color:#75715e>@ Read value at x9 into x12 (1 byte)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    cmp <span style=color:#a6e22e>x12</span>, <span style=color:#960050;background-color:#1e0010>10</span>                 <span style=color:#75715e>@ If   x12 == 10 (= \n)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    beq <span style=color:#960050;background-color:#1e0010>_convert_loop_newline</span>   <span style=color:#75715e>@ Then branch to newline code
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    sub <span style=color:#a6e22e>x12</span>, <span style=color:#a6e22e>x12</span>, <span style=color:#960050;background-color:#1e0010>48</span>            <span style=color:#75715e>@ Else sub 48 to get back to real number
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    mov <span style=color:#a6e22e>x14</span>, <span style=color:#960050;background-color:#1e0010>10</span>                 <span style=color:#75715e>@ So we can multiply by 10
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    mul <span style=color:#a6e22e>x11</span>, <span style=color:#a6e22e>x11</span>, <span style=color:#a6e22e>x14</span>           <span style=color:#75715e>@ Multiply accumulated total by 10
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    add <span style=color:#a6e22e>x11</span>, <span style=color:#a6e22e>x11</span>, <span style=color:#a6e22e>x12</span>           <span style=color:#75715e>@ Add new digit to accumulated total
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    b <span style=color:#960050;background-color:#1e0010>_convert_loop_end</span>         <span style=color:#75715e>@ Glorious success
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>_convert_loop_newline:
</span></span><span style=display:flex><span>    str <span style=color:#a6e22e>w11</span>, <span style=color:#960050;background-color:#1e0010>[</span><span style=color:#a6e22e>x10</span><span style=color:#960050;background-color:#1e0010>]</span>              <span style=color:#75715e>@ Store x11 (accumulated total) at memory
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                                <span style=color:#75715e>@ position of x10 (write position)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    add <span style=color:#a6e22e>x10</span>, <span style=color:#a6e22e>x10</span>, <span style=color:#960050;background-color:#1e0010>4</span>             <span style=color:#75715e>@ Increment x10 (write position) by 4 bytes
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    mov <span style=color:#a6e22e>x11</span>, <span style=color:#960050;background-color:#1e0010>0</span>                  <span style=color:#75715e>@ Reset x11 (accumulated total)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>                                <span style=color:#75715e>@ Onwards to _convert_loop_end
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>_convert_loop_end:
</span></span><span style=display:flex><span>    add <span style=color:#a6e22e>x9</span>, <span style=color:#a6e22e>x9</span>, <span style=color:#960050;background-color:#1e0010>1</span>               <span style=color:#75715e>@ Increment x9 (read position) by 1 byte
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    cmp <span style=color:#a6e22e>x13</span>, <span style=color:#a6e22e>x9</span>                 <span style=color:#75715e>@ Compare read position against end of buffer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    bne <span style=color:#960050;background-color:#1e0010>_convert_loop_start</span>     <span style=color:#75715e>@ If not at end of buffer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    str <span style=color:#a6e22e>w11</span>, <span style=color:#960050;background-color:#1e0010>[</span><span style=color:#a6e22e>x10</span><span style=color:#960050;background-color:#1e0010>]</span>              <span style=color:#75715e>@ Store our last number
</span></span></span></code></pre></div></details></p><blockquote><p>Note: At this point, we have stored the memory location of the start of our data inside the stack pointer, <code>sp</code> and the end of our data is in <code>x13</code>. These will both be useful in future</p></blockquote><p>There are a few new things in this code, namely the comparison , <code>cmp</code>, and branching, <code>beq</code>, <code>bne</code> operators. These are the fundamental building blocks of if statements and loops in modern programming languages. As you can see, we are also starting to write something resembling functions, eg <code>_convert_loop_start</code>, which are used to add some sense and readability to our control flow.</p><p>Comparison and branching operators allow us to write code such as the following very basic if statement - This can quite easily be turned into loops by jumping to an instruction further above the point in the program you are in at any point:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-armasm data-lang=armasm><span style=display:flex><span>cmp <span style=color:#a6e22e>x12</span>, <span style=color:#960050;background-color:#1e0010>10</span>                    <span style=color:#75715e>@ Compare the value in register x12 to 10
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>bne <span style=color:#960050;background-color:#1e0010>_code_to_run_if_not_equal</span>  <span style=color:#75715e>@ If x12 != 10, jump to the section of code called _code_to_run_if_not_equal
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>add <span style=color:#a6e22e>x12</span>, <span style=color:#960050;background-color:#1e0010>10</span>                    <span style=color:#75715e>@ Otherwise, add 10 to the value in register x12
</span></span></span></code></pre></div><p>After reading the <a href=https://adventofcode.com/2021/day/1/input>advent of code input file</a> into memory, we can read the contents using <a href=https://lldb.llvm.org/>lldb</a> to check that it contains what we expected. Lldb gives the following output when we read the first 16 blocks of memory at our stack pointer:</p><pre tabindex=0><code>(lldb) x/16x `$sp`
0x16fdef5c0: 0x000000bf 0x000000b9 0x000000bc 0x000000bd
0x16fdef5d0: 0x000000cc 0x000000d5 0x000000d7 0x000000e3
0x16fdef5e0: 0x000000de 0x000000dd 0x000000ec 0x000000eb
0x16fdef5f0: 0x000000ec 0x000000e8 0x000000e0 0x000000e4
</code></pre><blockquote><p>Note: These numbers are &ldquo;little-endian&rdquo;, ie, numbers towards the right are less significant than those on the left</p></blockquote><p>Using a Hex converter, we can translate this to the numbers that this represents, which luckily represents the correct numbers:</p><pre tabindex=0><code>0x16fdef5c0: 191 185 188 189
0x16fdef5d0: 204 213 215 227
0x16fdef5e0: 222 221 236 235
0x16fdef5f0: 236 232 224 228
</code></pre><h1 id=performing-the-calculation>Performing the calculation<a hidden class=anchor aria-hidden=true href=#performing-the-calculation>#</a></h1><p>Now, we have our numbers stored in memory correctly, we need to perform our calculation. This invovles looping through the numbers, comparing each number to the previous one. If the next number is larger than the previous, we need to increment a counter by 1.</p><p><details><summary markdown=span>Perform increment calculation</summary><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-armasm data-lang=armasm><span style=display:flex><span>_processing_start:
</span></span><span style=display:flex><span>    add <span style=color:#a6e22e>x9</span>, <span style=color:#960050;background-color:#1e0010>sp</span>, <span style=color:#960050;background-color:#1e0010>4</span>                <span style=color:#75715e>@ 1. Read position in the buffer (start off
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                                 <span style=color:#75715e>@    at sp + 2. This lets us avoid any issues
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                                 <span style=color:#75715e>@    relating to the first number having
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                                 <span style=color:#75715e>@    nothing to compare against)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    ldr <span style=color:#a6e22e>w11</span>, <span style=color:#960050;background-color:#1e0010>[sp]</span>                <span style=color:#75715e>@ 2. Previous 32-bit number
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    mov <span style=color:#a6e22e>x12</span>, <span style=color:#960050;background-color:#1e0010>0</span>                   <span style=color:#75715e>@ 3. Current 32-bit number
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    mov <span style=color:#a6e22e>x14</span>, <span style=color:#960050;background-color:#1e0010>0</span>                   <span style=color:#75715e>@ 4. A counter tracking increases
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    add <span style=color:#a6e22e>x13</span>, <span style=color:#a6e22e>x10</span>, <span style=color:#960050;background-color:#1e0010>4</span>              <span style=color:#75715e>@ 5. The end of our useful information
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>_count_loop_start:
</span></span><span style=display:flex><span>    ldr <span style=color:#a6e22e>w12</span>, <span style=color:#960050;background-color:#1e0010>[</span><span style=color:#a6e22e>x9</span><span style=color:#960050;background-color:#1e0010>]</span>                <span style=color:#75715e>@ Load current number into x12 (use w12 to
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                                 <span style=color:#75715e>@ get 32 bits)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    cmp <span style=color:#a6e22e>x12</span>, <span style=color:#a6e22e>x11</span>                 <span style=color:#75715e>@ Compare w12 and w11
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    blt <span style=color:#960050;background-color:#1e0010>_count_loop_no_increment</span> <span style=color:#75715e>@ If less than, don&#39;t increment counter
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>_count_loop_increment:
</span></span><span style=display:flex><span>    add <span style=color:#a6e22e>x14</span>, <span style=color:#a6e22e>x14</span>, <span style=color:#960050;background-color:#1e0010>1</span>              <span style=color:#75715e>@ Increment x14 (counter) by 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>_count_loop_no_increment:
</span></span><span style=display:flex><span>    mov <span style=color:#a6e22e>x11</span>, <span style=color:#a6e22e>x12</span>                 <span style=color:#75715e>@ Move current number into previous number
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    add <span style=color:#a6e22e>x9</span>, <span style=color:#a6e22e>x9</span>, <span style=color:#960050;background-color:#1e0010>4</span>                <span style=color:#75715e>@ Add 2 to read position
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    cmp <span style=color:#a6e22e>x9</span>, <span style=color:#a6e22e>x13</span>                  <span style=color:#75715e>@ Compare current read position to end of
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                                 <span style=color:#75715e>@ useful info
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    bne <span style=color:#960050;background-color:#1e0010>_count_loop_start</span>        <span style=color:#75715e>@ If not yet at end of file, back to start of
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                                 <span style=color:#75715e>@ loop
</span></span></span></code></pre></div></details></p><p>In the above code, we are using the register <code>x14</code> as our counter, and therefore out answer <em>should</em> be inside that register. Unfortunately, it is a 32-bit integer, so we need to convert it back to ASCII so that we can display it.</p><h1 id=printing-our-our-answer>Printing our our answer<a hidden class=anchor aria-hidden=true href=#printing-our-our-answer>#</a></h1><p>We can use a similar trick to before to do this conversion - Namely, we need to repeatedly divide the number by 10 and store the remainder, converting all of our remainders into ASCII until we get to the end of the number.</p><p>For example:</p><pre tabindex=0><code>1709 / 10 = 170 | 9
170 / 10  = 17  | 0
17 / 10   = 1   | 7
1 / 10    = 0   | 1
</code></pre><p>Reading backwards, we get our number in single integers. We can then add 48 to each of these to get our ASCII characters, and finally print to stdout.</p><p><details><summary markdown=span>Convert integer to ASCII and print to stdout</summary><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-armasm data-lang=armasm><span style=display:flex><span>_print_start:
</span></span><span style=display:flex><span>    mov <span style=color:#a6e22e>x9</span>, <span style=color:#960050;background-color:#1e0010>0</span>                   <span style=color:#75715e>@ The remainder
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    mov <span style=color:#a6e22e>x10</span>, <span style=color:#a6e22e>x14</span>                <span style=color:#75715e>@ Our remaining number
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    mov <span style=color:#a6e22e>x11</span>, <span style=color:#960050;background-color:#1e0010>0</span>                  <span style=color:#75715e>@ A counter of number of digits
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    mov <span style=color:#a6e22e>x12</span>, <span style=color:#960050;background-color:#1e0010>10</span>                 <span style=color:#75715e>@ To help divide by 10
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    mov <span style=color:#a6e22e>x13</span>, <span style=color:#960050;background-color:#1e0010>sp</span>                 <span style=color:#75715e>@ Write location for the characters to print
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    add <span style=color:#a6e22e>x13</span>, <span style=color:#a6e22e>x13</span>, <span style=color:#960050;background-color:#1e0010>3</span>             <span style=color:#75715e>@ Cheating a bit - I know the output is 4
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                                <span style=color:#75715e>@ digits, so this lets us start at a position
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                                <span style=color:#75715e>@ on the stack and work backwards without
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                                <span style=color:#75715e>@ running out of room.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    mov <span style=color:#a6e22e>x15</span>, <span style=color:#960050;background-color:#1e0010>0</span>                  <span style=color:#75715e>@ Helper
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    mov <span style=color:#a6e22e>x17</span>, <span style=color:#960050;background-color:#1e0010>0</span>                  <span style=color:#75715e>@ Another helper
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>_print_loop_start:
</span></span><span style=display:flex><span>    udiv <span style=color:#a6e22e>x15</span>, <span style=color:#a6e22e>x10</span>, <span style=color:#a6e22e>x12</span>          <span style=color:#75715e>@ Stores quotient in x15
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    mov <span style=color:#a6e22e>x17</span>, <span style=color:#a6e22e>x10</span>                <span style=color:#75715e>@ Store original number in x17
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    mov <span style=color:#a6e22e>x10</span>, <span style=color:#a6e22e>x15</span>                <span style=color:#75715e>@ Store quotient in x10
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    mul <span style=color:#a6e22e>x15</span>, <span style=color:#a6e22e>x15</span>, <span style=color:#a6e22e>x12</span>           <span style=color:#75715e>@ Store quotient * 10 in x15
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    sub <span style=color:#a6e22e>x9</span>, <span style=color:#a6e22e>x17</span>, <span style=color:#a6e22e>x15</span>            <span style=color:#75715e>@ Calculate remainder
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    add <span style=color:#a6e22e>x9</span>, <span style=color:#a6e22e>x9</span>, <span style=color:#960050;background-color:#1e0010>48</span>              <span style=color:#75715e>@ Convert to ascii
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    strb <span style=color:#a6e22e>w9</span>, <span style=color:#960050;background-color:#1e0010>[</span><span style=color:#a6e22e>x13</span><span style=color:#960050;background-color:#1e0010>]</span>              <span style=color:#75715e>@ Store character in memory
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    add <span style=color:#a6e22e>x11</span>, <span style=color:#a6e22e>x11</span>, <span style=color:#960050;background-color:#1e0010>1</span>             <span style=color:#75715e>@ Add 1 to counter
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    sub <span style=color:#a6e22e>x13</span>, <span style=color:#a6e22e>x13</span>, <span style=color:#960050;background-color:#1e0010>1</span>             <span style=color:#75715e>@ Decrease write location by 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    cmp <span style=color:#a6e22e>x10</span>, <span style=color:#960050;background-color:#1e0010>0</span>                  <span style=color:#75715e>@ If quotient = 0, we are done
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    bne <span style=color:#960050;background-color:#1e0010>_print_loop_start</span>       <span style=color:#75715e>@ Else, back to our print loop
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    add <span style=color:#a6e22e>x11</span>, <span style=color:#a6e22e>x11</span>, <span style=color:#960050;background-color:#1e0010>1</span>             <span style=color:#75715e>@ Add 1 to counter to print the final digit
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>_print_to_stdout:
</span></span><span style=display:flex><span>    mov <span style=color:#a6e22e>x0</span>, #<span style=color:#ae81ff>1</span>                  <span style=color:#75715e>@ 1 = stdout
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    mov <span style=color:#a6e22e>x1</span>, <span style=color:#a6e22e>x13</span>                 <span style=color:#75715e>@ String to print out
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    mov <span style=color:#a6e22e>x2</span>, <span style=color:#a6e22e>x11</span>                 <span style=color:#75715e>@ length of string
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    mov <span style=color:#a6e22e>x16</span>, #<span style=color:#ae81ff>4</span>                 <span style=color:#75715e>@ write
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    svc 0                       <span style=color:#75715e>@ Call
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>_exit:
</span></span><span style=display:flex><span>    mov     <span style=color:#a6e22e>x0</span>, #<span style=color:#ae81ff>0</span>              <span style=color:#75715e>@ Use 0 return code
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    mov     <span style=color:#a6e22e>x16</span>, #<span style=color:#ae81ff>1</span>             <span style=color:#75715e>@ Exit program
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    svc     0                   <span style=color:#75715e>@ Call
</span></span></span></code></pre></div></details></p><p>And finally, our answer has been printed to the console!</p><h1 id=what-did-i-learn>What did I learn?<a hidden class=anchor aria-hidden=true href=#what-did-i-learn>#</a></h1><p>It&rsquo;s really interesting trying to write code with literally zero abstractions - You have to really think about how computers work in their most basic form. I&rsquo;d recommend it as a challenge to anyone who likes computers.</p><p>I&rsquo;d never properly thought about how a program interacts with the operating system through syscalls, though it makes a lot of sense having been through this process.</p><p>Though my implementation is almost certainly not the most efficient from either a performance or lines-of-code perspective, the fact that this took over 200 lines of assembly code (admittedly a fair few of them are comments!) has really given me an appreciation of what early programmers accomplished, as well as a huge appreciation for how easy higher-level languages have made programming. You could write this program quite comfortably in 3 lines of Python!!</p><h1 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h1><p>A few interesting links that I found during this that really helped me during this process.</p><p><a href="https://titanwolf.org/Network/Articles/Article?AID=860a4086-c513-4475-a7b0-7ba01c4c48a8">Reading from a file</a></p><p><a href=https://lldb.llvm.org/use/map.html>LLDB cheatsheet</a></p><p><a href=https://www.scadacore.com/tools/programming-calculators/online-hex-converter/>Hex converter</a></p><p><a href=https://azeria-labs.com/arm-data-types-and-registers-part-2/>Some basics</a></p></div><footer class=post-footer></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://j-dsouza.github.io>James D'Souza</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>