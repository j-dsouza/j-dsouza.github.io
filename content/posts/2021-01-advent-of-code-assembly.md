---
title: "Assembly"
date: 2022-01-08T10:15:19Z
draft: true
---

# What's the goal?

In early January, a friend messaged saying that he was doing Day 1 of [Advent of Code](https://adventofcode.com/) in Assembly Code, and it was a really interesting challenge. As someone who has never touched Assembly Code, I naively thought _how hard can it be?_, and decided to join him.

> I'm running this on an ARM Macbook, so this post relates to my experiences with that architecture. Working with an Intel instruction set will vary, but the most of the ideas should be relatively transferrable as I'm not using any complex instructions here.

The [challenge](https://adventofcode.com/2021/day/1) boiled down to reading a list of numbers, and counting how many of them are larger than the previous number in the list. For example, in the following example there are `7` numbers that are larger than the previous number:

```
199 (N/A - no previous measurement)
200 (increased)
208 (increased)
210 (increased)
200 (decreased)
207 (increased)
240 (increased)
269 (increased)
260 (decreased)
263 (increased)
```

Easy, right? This is a pretty basic problem to solve in most modern programming languages, but without some of the abstractions provided to you by a modern programming language, things are not quite so easy..

The code I ended up writing to solve this and print the answer to stdout can be found [on my github](https://github.com/j-dsouza/assembly)

# How do you even run an assembly program?

To run an assembly program, like with any other programming language, you need to turn the code that you have written into something that the machine can understand. Whilst assembly is _close_ to direct machine code, its not quite there. In order to run it, we need to pass it through two programs, an assembler, and a linker. Both of these conveniently come with Mac developer tools, and the program names are `as` and `ld` respectively.

An **assembler**'s job is to convert assembly language mnemonics (instructions) into binary machine language, and translate names for memory addresses into numeric addresses.

The end result of the assembler is a binary 'object' file, given a `.o` extension by convention. The memory addresses generated by an assembler are actually offsets, as opposed to absolute locations. Generally, an object file will be linked with several other object files and libraries to produce a program.

The job of a **linker** is to link together these object files and libraries, by assigning absolute memory locations to everything. The output of this is a binary executable which can be directly run from the command line. In this post, we are only dealing with one assembly file, so there are no other object files or libraries to worry about, however, it does need to link our memory addresses to something that the operating system can understand.

Usage of these two is reasonably simple. I made a [small makefile](https://github.com/j-dsouza/assembly/blob/main/Makefile) to save on typing, but you would run something like the following in order to generate a binary executable called `bin/filename` from a source assembly file called `filename.s`

```bash
as -o filename.o filename.s
ld filename -o ./bin/filename -e _start -arch arm64 -L /Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/lib -lSystem
```

[Reading from a file](https://titanwolf.org/Network/Articles/Article?AID=860a4086-c513-4475-a7b0-7ba01c4c48a8)
[LLDB cheatsheet](https://lldb.llvm.org/use/map.html)
[Hex converter](https://www.scadacore.com/tools/programming-calculators/online-hex-converter/)
[Some basics](https://azeria-labs.com/arm-data-types-and-registers-part-2/)
[Mac syscalls](https://opensource.apple.com/source/xnu/xnu-1504.3.12/bsd/kern/syscalls.master)
